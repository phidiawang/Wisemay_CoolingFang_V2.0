/******************************************************************************
*
* Copyright 2006-2015 Freescale Semiconductor, Inc.
* Copyright 2016-2017 NXP
*
***************************************************************************/

#include "mc9s12zvml32.h"
#include "S12zvm_periph.h"
#include "freemaster.h"
#include "state_machine.h"
#include "mlib.h"
#include "gflib.h"
#include "gmclib.h"
#include "gdflib.h"
#include "motor_structure.h"
#include "S12ZVM_devconfig.h"
#include "meas_s12zvm.h"
#include "actuate_s12zvm.h"
#include "AddFunction.h"
//#include "MC_key.h"
// static configuration generated by MCAT
#include "PMSM_appconfig.h"

/*****************************************************************************
*
* Definitions
*
*****************************************************************************/
// Internal clock 1MHz, 100/50 MHz CPU/Bus clock, 8.33 MHz ADC clock
//#define _INTERNAL_CLOCK						// 1 MHz internal clock is used
//#define	CPMU_REFDIV		0
//#define	CPMU_SYNDIV		49
//#define	CPMU_POSTDIV	0
//#define	CPMU_REFFRQ		0
//#define	CPMU_VCOFRQ		3
//#define ADC_TIM			2
//#define	MIN_ADC_TRIGGER_FIRST	24
//#define	MIN_ADC_TRIGGER_SECOND	144
//#define	PWM_MODULO		5000
//#define	PWM_DEADTIME	50
#define TIM_PRESCALER 7 // Timer prescaler 128; 50 MHz/128 = 2.56 us
#define TIMER_1MS 390
//#define	SCI_BAUDRATE	5208
#define POWERLOOP_EN_CNT 1000 //unit:ms

//////////////////////////////////////////////////////////////////////////
/*//顺风启动参数------------------------------------------------------------------*/
#define NO_RETRIES 4                   // Number of times acquision is retried before system goes to FAILED_TO_START trip
#define REACQUIRE_THRESHOLD (3272 * 2) // This value is used to decide whether going too fast to reacquire.
#define VPH_THRESHOLD 24               ////______/----\_____
#define LEVEL_COUNT 6
#define FORWARDS 1
#define BACKWARDS 0
#define VPH_CH_RED 0x01
#define VPH_CH_YELLOW 0x02
#define VPH_CH_BLUE 0x03
/***** High speed scaling *********************
 * For 4 pole-pairs motors
 * Boundary values for 1.28 us timer period:
 * - Minimal speed:        100 rpm
 * - Minimal speed scaled: 164
 * - Maximal speed:        4400 rpm
 * - Maximal speed scaled: 32767
 *********************************************/
#define MOTOR_PP 4 //电机极对数
//#define TIMER_FREQ          390625//单位:HZ //50MH/128,2.56us ;详见时钟/总线频率宏定义
#define BASE_SPEED N_MAX             //单位:RPM //最大转速值，用于规一化转速到0-32767，
#define SPEED_CALC_NUMERATOR 5859375 //(uint32_t)(((60/MOTOR_PP)/2.56us)*1000000)////=5859375
#define PERIOD_100RPM 58594          //(SPEED_CALC_NUMERATOR/100RPM)
#define CHECK_MIN_SPEED (50)         // 50 rpm;

/*****************************************************************************
*
* Variables Definition
*
*****************************************************************************/
pmsmDrive_t drvFOC;          // Field Oriented Control Variables
driveStates_t cntrState;     // Responsible for stateMachine state propagation
appFaultStatus_t tempfaults; // Temporary faults to be indicated inhere
appFaultStatus_t permFaults; // Permanent faults to be indicated inhere
fm_scale_t fmScale;          // Scales for freemaster interface
measModule_t meas;
tPos_mode pos_mode;
AvIpeak_t AvIpeakCal;

static tBool focFastLoop(void);
static tBool focSlowLoop(void);
static tBool faultDetection();

tBool automaticMode(void);
static tBool CalcOpenLoop(openLoopPospe_t *openLoop, tFrac16 speedReqRamp);

void Motor_TailWind(void);
void AppCalibToCheckMotor(void);
void AppBrakeToAlignment(void);
void AppTranToBrake(void);
void AppFreewheelToRun(void);
void CheckMotorRunning(void);
void tim_init(void);

// Interrupts
INTERRUPT void TIMchan0_ISR();
INTERRUPT void PTUTrigger0Done_ISR(void);
INTERRUPT void PTUTrigger1Done_ISR(void);
INTERRUPT void ADC0error_ISR(void);
INTERRUPT void ADC1error_ISR(void);
INTERRUPT void ADC0done_ISR(void);
INTERRUPT void ADC1done_ISR(void);
INTERRUPT void PMFreloadA_ISR(void);

// Debug variables
static tFrac16 reload_PmfCnt;
volatile unsigned int AdcErrorLDOK, AdcErrorRSTAR, AdcErrorTRIG, AdcErrorEOL, AdcErrorCMD, AdcErrorIA;
volatile unsigned int AdcError0, AdcError1, TrigError0, TrigError1;
// End of debug variables
volatile tU16 Timer1msCNT;
volatile tU16 Timer10msCNT;
volatile tU16 TimerOLRampCNT;

// Open Loop and Closed loop speed ramp variants
volatile tFrac32 OL_SpeedRampInc = 0, CL_SpeedRampInc = 0, CL_SpeedRampDec = 0;

///////////////////////////////////////////////////////////////////////////////
/////////for winding
volatile tU16 BrakeLoopDuration;
volatile tU16 LinkupDuration;
volatile unsigned char brakeEnableFlags;
volatile tU32 RunningChk_counter;
volatile tU8 ADC_channel = 2;
//unsigned int period_measurement = 2863;
volatile tU16 vph_red, vph_yellow, vph_blue;
volatile tU16 timeBEMF;
volatile tU16 NextCmtSector, ActualCmtSector;
volatile tFrac16 actualSpeed;
volatile tU16 NextCmtPeriod, duty_cycle;
volatile tU16 phaseVoltage;

/*****************************************************************************
*
* Function: void initTIM(void)
*
* Description: Timer module configuration
*
*****************************************************************************/
void tim_init(void)
{

    TIM0TIOS_IOS0 = 1;
    TIM0TIOS_IOS3 = 1; // Set channel 1 as output compare

    TIM0TSCR1_PRNT = 0; // NON Precision timer

    TIM0TCTL2_OL0 = 0; // Toggle output of tim chan 0
    TIM0TCTL2_OM0 = 0;
    TIM0TCTL2_OL3 = 0; // No action on output of tim chan 3
    TIM0TCTL2_OM3 = 0;

    TIM0TIE_C0I = 0; // Enable Interrupts
    TIM0TIE_C3I = 0; // Enable Interrupts

    TIM0TSCR2_PR = TIM_PRESCALER;

    TIM0TC3 = TIMER_1MS; // Interrupt to be every ~ 1[ms]

    TIM0OCPD = 0xff; // disconnect all output compare pins

    TIM0TSCR1_TEN = 1;
}

/*****************************************************************************
*
* Function: void main(void)
*
* Description: main function
*
*****************************************************************************/
void main(void)
{
    cpmu_init();
    pim_init();
    pmf_init();
    ptu_init();
    adc0_init();
    adc1_init();
    sci1_init();
    gdu_init();
    tim_init();

    FMSTR_Init();
    FaultVariablesInit();
    //Key_init();
    mcFaultDect.mcStallCnt = 0;
    mcFaultDect.SecondStart = 0;

    cntrState.state = reset;
    cntrState.event = e_reset;

    //Default setting of a FOC Control Mode
    cntrState.usrControl.FOCcontrolMode = speedControl;

    EnableInterrupts;
    //PTT_PTT2 = 1;

    for (;;)
    {
        FMSTR_Poll();
        //cntrState.usrControl.switchAppOnOff = true;
        //drvFOC.pospeControl.wRotElReq = FRAC16(1000.0/4000.0);
    }
}

/*****************************************************************************
*
* Function: void ADC0error_ISR(void)
*
* Description: ADC0 Error Interrupt Service Routine
*
*****************************************************************************/
INTERRUPT void ADC0error_ISR(void)
{
    char tmpAdcEIF;

    EnableInterrupts;
    AdcError0++;
    permFaults.mcu.B.ADC_Error = 1;
    tmpAdcEIF = ADC0EIF;

    if (tmpAdcEIF & 0x02)
    { // Load Ok Error
        AdcErrorLDOK++;
        ADC0EIF = 0x02;
    }
    if (tmpAdcEIF & 0x04)
    { // Restart Request Error
        AdcErrorRSTAR++;
        ADC0EIF = 0x04;
    }
    if (tmpAdcEIF & 0x08)
    { // Trigger Error => Soft Reset
        AdcErrorTRIG++;
        ADC0CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x20)
    { // End Of List Error => Soft Reset
        AdcErrorEOL++;
        ADC0CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x40)
    { // Command Value Error => Soft Reset
        AdcErrorCMD++;
        ADC0CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x80)
    { // Illegal Access Error => Soft Reset
        AdcErrorIA++;
        ADC0CTL_0_ADC_SR = 1;
    }
}

/*****************************************************************************
*
* Function: void ADC1error_ISR(void)
*
* Description: ADC1 Error Interrupt Service Routine
*
*****************************************************************************/
INTERRUPT void ADC1error_ISR(void)
{
    char tmpAdcEIF;

    EnableInterrupts;
    AdcError1++;
    permFaults.mcu.B.ADC_Error = 1;
    tmpAdcEIF = ADC1EIF;

    if (tmpAdcEIF & 0x02)
    { // Load Ok Error
        AdcErrorLDOK++;
        ADC1EIF = 0x02;
    }
    if (tmpAdcEIF & 0x04)
    { // Restart Request Error
        AdcErrorRSTAR++;
        ADC1EIF = 0x04;
    }
    if (tmpAdcEIF & 0x08)
    { // Trigger Error => Soft Reset
        AdcErrorTRIG++;
        ADC1CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x20)
    { // End Of List Error => Soft Reset
        AdcErrorEOL++;
        ADC1CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x40)
    { // Command Value Error => Soft Reset
        AdcErrorCMD++;
        ADC1CTL_0_ADC_SR = 1;
    }
    if (tmpAdcEIF & 0x80)
    { // Illegal Access Error => Soft Reset
        AdcErrorIA++;
        ADC1CTL_0_ADC_SR = 1;
    }
}

/*****************************************************************************
*
* Function: void ADC0done_ISR(void)
*
* Description: ADC0 Conversion Done Interrupt Service Routine
*
*****************************************************************************/
INTERRUPT void ADC0done_ISR(void)
{
    EnableInterrupts;
    ADC0CONIF = 1; // Clear flag
}

/***************************************************************************/ /*!
*
* @brief   ADC interrupt service routine for Current loop of FOC
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void ADC1done_ISR(void)
{
    EnableInterrupts;
    ADC1CONIF = 1; // Clear flag
}

/***************************************************************************/ /*!
*
* @brief   ADC interrupt service routine for Current loop of FOC
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void PMFreloadA_ISR(void)
{
    static tBool getFcnStatus;

    EnableInterrupts;

    PTT_PTT2 = 0; // set the PTT0 pin to track the code performance

    // Read the user control interface
    //cntrState.usrControl.btSpeedUp   = PTP_PTP1;
    //cntrState.usrControl.btSpeedDown = PTP_PTP2;

    // User switch should be checked only if not in init state (see state machine table)
    //if(cntrState.state != init)
    //cntrState.usrControl.btFlipFlop  = PTT_PTT2;//

    // User accessible switch for stopping the application.

    // if (cntrState.usrControl.btFlipFlop ^ cntrState.usrControl.btFlipFlopTemp)
    // {
    //     cntrState.usrControl.btFlipFlopTemp = cntrState.usrControl.btFlipFlop;
    //     cntrState.usrControl.switchAppOnOff = (cntrState.usrControl.btFlipFlop) ? false : true;
    // }

    // User accessible switch for stopping the application.
//    if (cntrState.usrControl.switchAppOnOff ^ cntrState.usrControl.switchAppOnOffState)
//    {
//        cntrState.usrControl.switchAppOnOffState = cntrState.usrControl.switchAppOnOff;
//        cntrState.event = (cntrState.usrControl.switchAppOnOff) ? e_app_on : e_app_off;
//    }

    getFcnStatus = true;

    // Phase currents and DCB voltage measurement
    getFcnStatus = Meas_Get3PhCurrent(&meas, &drvFOC.iAbcFbck, drvFOC.svmSector);
    getFcnStatus &= Meas_GetTemperature(&meas);
    getFcnStatus &= Meas_GetUdcVoltage(&meas, &drvFOC.uDcbFilter);
    drvFOC.f16Udcb = meas.measured.f16Udcb.filt;

    //GetIABCpeak();
    Fault_Overcurrent(&mcFaultDect);

    Motor_TailWind(); ////for check motor running

    if (++Timer1msCNT >= 10)
    {
        Timer1msCNT = 0;
        if (pos_mode == sensorless1)
            Timer10msCNT++;
        else
            Timer10msCNT = 0;

        if ((pos_mode == force) && (cntrState.state == run)) //Delay for OL_Rampup
            TimerOLRampCNT++;
        else
            TimerOLRampCNT = 0;
        //Key_Filtrate();
        //User_Key_handle();
        //cntrState.event   = (cntrState.usrControl.switchAppOnOff) ? e_app_on: e_app_off;
        if (BrakeLoopDuration > 0)
            BrakeLoopDuration--; ///add by phidia.wang 2018.09.26
        if (LinkupDuration > 0)
            LinkupDuration--; ///add by phidia.wang 2018.09.26
        if (cntrState.state == checkM)
            RunningChk_counter++; ///add by phidia.wang 2018.09.26

        // Fault detection routine, must be executed prior application state machine
        getFcnStatus &= faultDetection();
        if (getFcnStatus)
            cntrState.event = e_fault;
    }

    // Execute State table with newly measured data
    state_table[cntrState.event][cntrState.state]();
    //state_LED[cntrState.state]();

    FMSTR_Recorder();

    PTT_PTT2 = 1; // clear the PTT0 pin to track the code performance

    PMFFQCA_PWMRFA = 1; // Clear flag
}

/***************************************************************************/ /*!
*
* @brief   After reset MCAT INIT
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateReset()
{
    tBool ResetFcnStatus = true;
    /*-----------------------------------------------------
		Application State Machine - state identification
		----------------------------------------------------- */
    // Entering state fault
    cntrState.state = reset;
    cntrState.event = e_reset;

    // Turn off Actuator's output (PWM, GDU)
    DisableOutput();
    /*------------------------------------
	     * Freemaster variables
	     * ----------------------------------*/
    fmScale.current = FM_I_SCALE;
    fmScale.voltage = FM_U_SCALE;
    fmScale.dcb_voltage = FM_U_DCB_SCALE;
    fmScale.speed_w_e = FM_SPEED_RAD_EL_SCALE;
    fmScale.speed_n_m = FM_SPEED_RPM_MEC_SCALE;
    fmScale.position = FM_POSITION_DEG_SCALE;
    //fmScale.speed_ramp									 = FM_SPEED_RAMP_RPM_SCALE;

    drvFOC.alignCntrInit = ALIGN_DURATION;
    drvFOC.alignVoltage = ALIGN_VOLTAGE;

    /*------------------------------------
	     * Currents
	     * ----------------------------------*/
    drvFOC.iAbcFbck.f16Arg1 = 0;
    drvFOC.iAbcFbck.f16Arg2 = 0;
    drvFOC.iAbcFbck.f16Arg3 = 0;

    drvFOC.iAlBeFbck.f16Arg1 = 0;
    drvFOC.iAlBeFbck.f16Arg2 = 0;

    drvFOC.iDQReq.f16Arg1 = 0;
    drvFOC.iDQReq.f16Arg2 = 0;

    drvFOC.iDQReqZC.f16Arg1 = 0;
    drvFOC.iDQReqZC.f16Arg2 = 0;

    drvFOC.iDQErr.f16Arg1 = 0;
    drvFOC.iDQErr.f16Arg2 = 0;

    drvFOC.iDQFbck.f16Arg1 = 0;
    drvFOC.iDQFbck.f16Arg2 = 0;

    /*------------------------------------
	     * Voltages
	     * ----------------------------------*/
    drvFOC.uAlBeReq.f16Arg1 = 0;
    drvFOC.uAlBeReq.f16Arg2 = 0;

    drvFOC.uAlBeReqDCB.f16Arg1 = 0;
    drvFOC.uAlBeReqDCB.f16Arg2 = 0;

    drvFOC.uDQReq.f16Arg1 = 0;
    drvFOC.uDQReq.f16Arg2 = 0;

    /*------------------------------------
	     * Speed/Position
	     * ----------------------------------*/
    drvFOC.thTransform.f16Arg1 = 0;
    drvFOC.thTransform.f16Arg2 = 0;

    /*------------------------------------
	     * SVC-PWM variables
	     * ----------------------------------*/
    drvFOC.svmSector = 1;

    drvFOC.pwm16.f16Arg1 = 0;
    drvFOC.pwm16.f16Arg2 = 0;
    drvFOC.pwm16.f16Arg3 = 0;

    /*------------------------------------
	     * FOC variables
	     * ----------------------------------*/

    // D-axis PI controller
    drvFOC.dAxisPI.f32Acc = 0;
    drvFOC.dAxisPI.f16CC1sc = D_CC1SC;
    drvFOC.dAxisPI.f16CC2sc = D_CC2SC;
    drvFOC.dAxisPI.f16InErrK1 = 0;
    drvFOC.iCLoop_Limit.f16UpperLimit = CLOOP_LIMIT;
    drvFOC.iCLoop_Limit.f16LowerLimit = MLIB_Neg_F16(drvFOC.iCLoop_Limit.f16UpperLimit);

    drvFOC.dAxisPI.f16UpperLimit = drvFOC.iCLoop_Limit.f16UpperLimit;
    drvFOC.dAxisPI.f16LowerLimit = drvFOC.iCLoop_Limit.f16LowerLimit;
    drvFOC.dAxisPI.u16NShift = D_NSHIFT;

    // Q-axis PI controller
    drvFOC.qAxisPI.f32Acc = 0;
    drvFOC.qAxisPI.f16CC1sc = Q_CC1SC;
    drvFOC.qAxisPI.f16CC2sc = Q_CC2SC;
    drvFOC.qAxisPI.f16InErrK1 = 0;
    drvFOC.qAxisPI.f16UpperLimit = drvFOC.iCLoop_Limit.f16UpperLimit;
    drvFOC.qAxisPI.f16LowerLimit = drvFOC.iCLoop_Limit.f16LowerLimit;
    drvFOC.qAxisPI.u16NShift = Q_NSHIFT;

    // DCBus 1st order filter; Fcut = 100Hz, Ts = 100e-6
    drvFOC.uDcbFilter.trFiltCoeff.f16B0 = UDCB_IIR_B0;
    drvFOC.uDcbFilter.trFiltCoeff.f16B1 = UDCB_IIR_B1;
    drvFOC.uDcbFilter.trFiltCoeff.f16A1 = UDCB_IIR_A1;
    GDFLIB_FilterIIR1Init_F16(&drvFOC.uDcbFilter);

    drvFOC.elimDcbRip.f16ModIndex = FRAC16(0.866025403784439);
    drvFOC.elimDcbRip.f16ArgDcBusMsr = 0;

    OL_SpeedRampInc = OL_START_RAMP_INC;
    //OL_SpeedRampDec = OL_START_RAMP_DEC;
    CL_SpeedRampInc = SPEED_RAMP_UP;
    CL_SpeedRampDec = SPEED_RAMP_DOWN;

    drvFOC.speedRampPos.f32RampUp = OL_SpeedRampInc;
    drvFOC.speedRampPos.f32RampDown = OL_SpeedRampInc; //would be OL_SpeedRampDec, if needed
    drvFOC.speedRampPos.f32State = 0;

    drvFOC.speedRampNeg.f32RampUp = OL_SpeedRampInc;
    drvFOC.speedRampNeg.f32RampDown = OL_SpeedRampInc; //would be OL_SpeedRampDec, if needed
    drvFOC.speedRampNeg.f32State = 0;

    drvFOC.pospeControl.wRotElReq = 0;
    drvFOC.pospeControl.wRotEl = 0;
    drvFOC.pospeControl.wRotElReqRamp = 0;

    drvFOC.speedPI.f16PropGain = SPEED_PI_PROP_GAIN;
    drvFOC.speedPI.s16PropGainShift = SPEED_PI_PROP_SHIFT;
    drvFOC.speedPI.f16IntegGain = SPEED_PI_INTEG_GAIN;
    drvFOC.speedPI.s16IntegGainShift = SPEED_PI_INTEG_SHIFT;
    drvFOC.speedPI.f32IntegPartK_1 = 0;
    drvFOC.speedPI.f16UpperLimit = SPEED_LOOP_HIGH_LIMIT;
    drvFOC.speedPI.f16LowerLimit = SPEED_LOOP_LOW_LIMIT;

    // Position observer output
    drvFOC.pospeSensorless.wRotEl = 0;
    drvFOC.pospeSensorless.thRotEl = 0;

    drvFOC.pospeSensorless.DQtoGaDeError = 0;
    drvFOC.pospeSensorless.bEMFObs.pParamD.f16CC1sc = BEMF_DQ_CC1_GAIN;
    drvFOC.pospeSensorless.bEMFObs.pParamD.f16CC2sc = BEMF_DQ_CC2_GAIN;
    drvFOC.pospeSensorless.bEMFObs.pParamD.f16LowerLimit = FRAC16(-1.0);
    drvFOC.pospeSensorless.bEMFObs.pParamD.f16UpperLimit = FRAC16(1.0);
    drvFOC.pospeSensorless.bEMFObs.pParamD.u16NShift = BEMF_DQ_NSHIFT;
    drvFOC.pospeSensorless.bEMFObs.pParamQ.f16CC1sc = BEMF_DQ_CC1_GAIN;
    drvFOC.pospeSensorless.bEMFObs.pParamQ.f16CC2sc = BEMF_DQ_CC2_GAIN;
    drvFOC.pospeSensorless.bEMFObs.pParamQ.f16LowerLimit = FRAC16(-1.0);
    drvFOC.pospeSensorless.bEMFObs.pParamQ.f16UpperLimit = FRAC16(1.0);
    drvFOC.pospeSensorless.bEMFObs.pParamQ.u16NShift = BEMF_DQ_NSHIFT;
    drvFOC.pospeSensorless.bEMFObs.s16Shift = BEMF_SHIFT;
    drvFOC.pospeSensorless.bEMFObs.f16UGain = U_GAIN;
    drvFOC.pospeSensorless.bEMFObs.f16WIGain = WI_GAIN;
    drvFOC.pospeSensorless.bEMFObs.f16EGain = E_GAIN;
    drvFOC.pospeSensorless.bEMFObs.f16IGain = I_GAIN;

    AMCLIB_BemfObsrvDQInit_F16(&drvFOC.pospeSensorless.bEMFObs);

    drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16CC1sc = TO_CC1SC;
    drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16CC2sc = TO_CC2SC;
    drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16LowerLimit = FRAC16(-1.0);
    drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16UpperLimit = FRAC16(1.0);
    drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift = TO_NSHIFT;
    drvFOC.pospeSensorless.TrackObsrv.pParamInteg.f16C1 = TO_THETA_GAIN;
    drvFOC.pospeSensorless.TrackObsrv.pParamInteg.u16NShift = TO_THETA_SHIFT;

    AMCLIB_TrackObsrvInit_F16(&drvFOC.pospeSensorless.TrackObsrv);

    drvFOC.pospeSensorless.filterMA.u16NSamples = POSPE_SPEED_FILTER_MA_NPOINT;
    GDFLIB_FilterMAInit_F16(&drvFOC.pospeSensorless.filterMA);

    drvFOC.pospeSensorless.wRotEl = 0;
    drvFOC.pospeSensorless.thRotEl = 0;
    drvFOC.pospeSensorless.wRotElMatch_1 = MERG_SPEED_1_TRH;
    drvFOC.pospeSensorless.wRotElMatch_2 = MERG_SPEED_2_TRH;

    drvFOC.pospeSensorless.iQUpperLimit = SPEED_LOOP_HIGH_LIMIT;
    drvFOC.pospeSensorless.iQLowerLimit = SPEED_LOOP_LOW_LIMIT;

    drvFOC.pospeOpenLoop.integ.f16InK1 = 0;
    drvFOC.pospeOpenLoop.integ.f32State = 0;
    drvFOC.pospeOpenLoop.integ.f16C1 = SCALAR_INTEG_GAIN;
    drvFOC.pospeOpenLoop.integ.u16NShift = SCALAR_INTEG_SHIFT;

    drvFOC.pospeOpenLoop.thRotEl = 0;
    drvFOC.pospeOpenLoop.wRotEl = 0;

    drvFOC.pospeOpenLoop.iQUpperLimit = OL_START_I;
    drvFOC.pospeOpenLoop.iQLowerLimit = MLIB_Neg_F16(drvFOC.pospeOpenLoop.iQUpperLimit);

    // Scalar control
    drvFOC.scalarControl.VHzRatioReq = SCALAR_VHZ_FACTOR_GAIN;
    drvFOC.scalarControl.VHzRatioReq_Shift = SCALAR_VHZ_FACTOR_SHIFT;

    // Default mode of operation
    cntrState.usrControl.controlMode = automatic;
    pos_mode = force;

    if (!ResetFcnStatus)
    {
        // Fault in initialisation state
        tempfaults.stateMachine.B.InitError = 1; // Mark the initialisation fault
        cntrState.event = e_fault;               // prepare for transition to fault state.
    }
    else
    {
        // Initialisation phase successfully done
        cntrState.event = e_reset_done; // prepare for transition to next state.
    }
}

/***************************************************************************/ /*!
*
* @brief   FAULT state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateFault()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    // Entering state fault
    cntrState.state = fault;
    cntrState.event = e_fault;

    // Turn off Actuator's output (PWM, GDU)
    DisableOutput();

    // Indicate State Machine fault state invoked by irrelevant event call
    if ((permFaults.mcu.R == 0) && (permFaults.motor.R == 0) && (permFaults.stateMachine.R == 0))
        permFaults.stateMachine.B.FOCError = 1;

    // Disable user application switch
    cntrState.usrControl.switchAppOnOff = false;
    cntrState.usrControl.switchAppOnOffState = false;

    // Clear fault by on board user buttons.
    // Simultaneous press clearing faults
    //    if (!cntrState.usrControl.btSpeedUp &&
    //    	!cntrState.usrControl.btSpeedDown)
    //        cntrState.usrControl.switchFaultClear = true;

    if (cntrState.usrControl.switchFaultClear)
    {
        if (ClearDriverError() && ClearPMF_Faults() && ClearPTU_Errors())
        {
            // Clear all of the HW/MCU faults such as GDU, PWM, ...

            // Clear permanent SW faults
            permFaults.mcu.R = 0x0;          // Clear mcu faults
            permFaults.motor.R = 0x0;        // Clear motor faults
            permFaults.stateMachine.R = 0x0; // Clear state machine faults

            // When all Faults cleared prepare for transition to next state.
            cntrState.usrControl.readFault = true;
            cntrState.usrControl.switchFaultClear = false;
            cntrState.event = e_fault_clear;
            mcFaultSource = FaultNoSource;
        }
    }
}

/***************************************************************************/ /*!
*
* @brief   INIT state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateInit()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    tBool InitFcnStatus;
    cntrState.state = init;
    cntrState.event = e_init;

    //Switch off PWM output, GDU output
    DisableOutput();

    /*------------------------------------
     * General use variables
     * ----------------------------------*/
    InitFcnStatus = false;

    /*------------------------------------
     * Application state machine variables
     * ----------------------------------*/
    // Reset state of all user control variables
    cntrState.usrControl.switchAppOnOff = false;
    cntrState.usrControl.switchAppOnOffState = false;
    cntrState.usrControl.switchFaultClear = false;
    cntrState.usrControl.switchAppReset = false;

    cntrState.usrControl.ledCounter = 0;
    cntrState.usrControl.ledFlashing = 1250;

    drvFOC.pospeControl.speedLoopCntr = 0;

    drvFOC.alignCntr = drvFOC.alignCntrInit;

    InitFcnStatus = Meas_Clear(&meas);
    meas.param.u16CalibSamples = 10; // number of samples = 2^u16CalibSamples
    meas.offset.f16Idcb.filtParam.u16NSamples = meas.param.u16CalibSamples;

    /*------------------------------------
     * Currents
     * ----------------------------------*/
    drvFOC.iAbcFbck.f16Arg1 = 0;
    drvFOC.iAbcFbck.f16Arg2 = 0;
    drvFOC.iAbcFbck.f16Arg3 = 0;

    drvFOC.iAlBeFbck.f16Arg1 = 0;
    drvFOC.iAlBeFbck.f16Arg2 = 0;

    drvFOC.iDQReq.f16Arg1 = 0;
    drvFOC.iDQReq.f16Arg2 = 0;

    drvFOC.iDQReqZC.f16Arg1 = 0;
    drvFOC.iDQReqZC.f16Arg2 = 0;

    drvFOC.iDQErr.f16Arg1 = 0;
    drvFOC.iDQErr.f16Arg2 = 0;

    drvFOC.iDQFbck.f16Arg1 = 0;
    drvFOC.iDQFbck.f16Arg2 = 0;

    drvFOC.pospeOpenLoop.iQLowerLimit = MLIB_Neg_F16(drvFOC.pospeOpenLoop.iQUpperLimit);

    /*------------------------------------
     * Voltages
     * ----------------------------------*/
    drvFOC.uAlBeReq.f16Arg1 = 0;
    drvFOC.uAlBeReq.f16Arg2 = 0;

    drvFOC.uAlBeReqDCB.f16Arg1 = 0;
    drvFOC.uAlBeReqDCB.f16Arg2 = 0;

    drvFOC.uDQReq.f16Arg1 = 0;
    drvFOC.uDQReq.f16Arg2 = 0;

    /*------------------------------------
     * Speed/Position
     * ----------------------------------*/
    drvFOC.thTransform.f16Arg1 = 0;
    drvFOC.thTransform.f16Arg2 = 0;

    /*------------------------------------
     * SVC-PWM variables
     * ----------------------------------*/
    drvFOC.svmSector = 1;

    drvFOC.pwm16.f16Arg1 = 0;
    drvFOC.pwm16.f16Arg2 = 0;
    drvFOC.pwm16.f16Arg3 = 0;

    /*------------------------------------
     * FOC variables
     * ----------------------------------*/

    // D-axis PI controller
    drvFOC.dAxisPI.f32Acc = 0;
    drvFOC.dAxisPI.f16InErrK1 = 0;

    // Q-axis PI controller
    drvFOC.qAxisPI.f32Acc = 0;
    drvFOC.qAxisPI.f16InErrK1 = 0;

    // DCBus 1st order filter; Fcut = 100Hz, Ts = 100e-6
    drvFOC.uDcbFilter.trFiltCoeff.f16B0 = UDCB_IIR_B0;
    drvFOC.uDcbFilter.trFiltCoeff.f16B1 = UDCB_IIR_B1;
    drvFOC.uDcbFilter.trFiltCoeff.f16A1 = UDCB_IIR_A1;
    GDFLIB_FilterIIR1Init_F16(&drvFOC.uDcbFilter);

    drvFOC.elimDcbRip.f16ModIndex = FRAC16(0.866025403784439);
    drvFOC.elimDcbRip.f16ArgDcBusMsr = 0;

    drvFOC.speedRampPos.f32RampUp = OL_SpeedRampInc;
    drvFOC.speedRampPos.f32RampDown = OL_SpeedRampInc;
    drvFOC.speedRampPos.f32State = 0;

    drvFOC.speedRampNeg.f32RampUp = OL_SpeedRampInc;
    drvFOC.speedRampNeg.f32RampDown = OL_SpeedRampInc;
    drvFOC.speedRampNeg.f32State = 0;

    drvFOC.speedPI.f32IntegPartK_1 = 0;

    drvFOC.pospeControl.wRotEl = 0;
    drvFOC.pospeControl.wRotElReqRamp = 0;

    // Position observer
    drvFOC.pospeSensorless.wRotEl = 0;
    drvFOC.pospeSensorless.thRotEl = 0;

    AMCLIB_BemfObsrvDQInit_F16(&drvFOC.pospeSensorless.bEMFObs);
    AMCLIB_TrackObsrvInit_F16(&drvFOC.pospeSensorless.TrackObsrv);

    GDFLIB_FilterMAInit_F16(&drvFOC.pospeSensorless.filterMA);

    drvFOC.pospeOpenLoop.thRotEl = 0;
    drvFOC.pospeOpenLoop.wRotEl = 0;

    // Default mode of operation
    cntrState.usrControl.controlMode = automatic;
    pos_mode = force;
    control_flags.INIT_ACQUIRE = FALSE;

    if (!InitFcnStatus)
    {
        // Fault in initialisation state
        tempfaults.stateMachine.B.InitError = 1; // Mark the initialisation fault
        cntrState.event = e_fault;               // prepare for transition to fault state.
    }
    else
    {
        // Initialisation phase successfully done
        cntrState.event = e_init_done; // prepare for transition to next state.
    }
}

/***************************************************************************/ /*!
*
* @brief   READY state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateReady()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    cntrState.state = ready;
    cntrState.event = e_ready;

    if (cntrState.usrControl.switchAppReset == true)
    {
        cntrState.event = e_reset;
        cntrState.usrControl.switchAppReset = false;
    }
}

/***************************************************************************/ /*!
*
* @brief   CALIBRATION state - ADC calibration state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateCalib()
{
    /*-----------------------------------------------------
      Application State Machine - state identification
    ----------------------------------------------------- */
    tBool CalibStatus;

    cntrState.state = calib;
    cntrState.event = e_calib;
    CalibStatus = false;

    // Turn off actuator output
    DisableOutput();

    CalibStatus = Meas_CalibCurrentSense(&meas, drvFOC.svmSector);

    // Apply 0.5 duty cycle
    drvFOC.pwm16.f16Arg1 = FRAC16(0.5);
    drvFOC.pwm16.f16Arg2 = FRAC16(0.5);
    drvFOC.pwm16.f16Arg3 = FRAC16(0.5);

    SetDutycycle(&drvFOC.pwm16, 2);
    //RunningChk_counter = 0;

    // Exit the calibration state when DC calibration is done for all sectors
    if (CalibStatus)
    {
        // Calibration sequence has successfully finished
        //cntrState.event = e_calib_done;
        AppCalibToCheckMotor();
    }
}

/***************************************************************************/ /*!
*
* @brief   ALIGNMENT state - motor control d-axes alignment
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateAlign()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    tBool AlignStatus;

    cntrState.state = align;
    cntrState.event = e_align;

    // Turn on Actuator output on (PWM,GDU)
    EnableOutput();

    // Align sequence is at the beginning
    AlignStatus = true;

    drvFOC.uDQReq.f16Arg1 = drvFOC.alignVoltage;
    drvFOC.uDQReq.f16Arg2 = FRAC16(0);

    drvFOC.thTransform.f16Arg1 = GFLIB_Sin(0);
    drvFOC.thTransform.f16Arg2 = GFLIB_Cos(0);

    GMCLIB_ParkInv(&(drvFOC.uAlBeReq), &(drvFOC.thTransform), &(drvFOC.uDQReq));
    drvFOC.svmSector = GMCLIB_SvmStd(&(drvFOC.pwm16), &(drvFOC.uAlBeReq));

    // when alignment time elapse
    if (--(drvFOC.alignCntr) <= 0)
    {
        drvFOC.iDQReq.f16Arg1 = FRAC16(0.0);
        drvFOC.iDQReq.f16Arg2 = FRAC16(0.0);

        drvFOC.uDQReq.f16Arg1 = 0;
        drvFOC.uDQReq.f16Arg2 = 0;

        drvFOC.dAxisPI.f16InErrK1 = 0;
        drvFOC.dAxisPI.f32Acc = 0;

        drvFOC.qAxisPI.f16InErrK1 = 0;
        drvFOC.qAxisPI.f32Acc = 0;

        drvFOC.pwm16.f16Arg1 = FRAC16(0.5);
        drvFOC.pwm16.f16Arg2 = FRAC16(0.5);
        drvFOC.pwm16.f16Arg3 = FRAC16(0.5);

        drvFOC.svmSector = 2;

        if (!AlignStatus)
        {
            tempfaults.stateMachine.B.AlignError = 1;
        }
        else
        {
            cntrState.event = e_align_done;
        }
    }

    SetDutycycle(&drvFOC.pwm16, drvFOC.svmSector);
}

/***************************************************************************/ /*!
*
* @brief   RUN state
*
* @param   none
*
* @return  none
*
******************************************************************************/
void stateRun()
{
    static tBool stateRunStatus;

    stateRunStatus = false;

    //PTT_PTT0 = 1;		// Set debug pin to record execution time
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    cntrState.state = run;
    cntrState.event = e_run;

    /*-----------------------------------------------------
        Calculate positions
     ----------------------------------------------------- */
    if (pos_mode != sensorless1)
    {
        if (pos_mode == linkup)
        {
            drvFOC.pospeControl.wRotElReqRamp = MLIB_DivSat_F16(actualSpeed, N_MAX); //FRAC16((float)actualSpeed/N_MAX)//
        }

        CalcOpenLoop(&drvFOC.pospeOpenLoop, drvFOC.pospeControl.wRotElReqRamp);
    }

    // Start calculation of the Bemf Observer in tracking mode
    if (pos_mode != force)
    {
        drvFOC.pospeSensorless.DQtoGaDeError = AMCLIB_BemfObsrvDQ_F16(&drvFOC.iAlBeFbck, &drvFOC.uAlBeReq, drvFOC.pospeSensorless.wRotEl, drvFOC.pospeSensorless.thRotEl, &drvFOC.pospeSensorless.bEMFObs);
        AMCLIB_TrackObsrv_F16(drvFOC.pospeSensorless.DQtoGaDeError, &drvFOC.pospeSensorless.thRotEl, &drvFOC.pospeSensorless.wRotEl, &drvFOC.pospeSensorless.TrackObsrv);
        drvFOC.pospeSensorless.wRotEl = GDFLIB_FilterMA_F16(drvFOC.pospeSensorless.wRotEl, &drvFOC.pospeSensorless.filterMA);
    }

    if (pos_mode == tracking)
    {
        drvFOC.pospeOpenLoop.thDifOpenLEstim = MLIB_Sub_F16(drvFOC.pospeSensorless.thRotEl, drvFOC.pospeOpenLoop.thRotEl);
    }

    /*-----------------------------------------------------
	Get positions according to selected mode
	----------------------------------------------------- */
    // Selecting 0 will disable the "AUTOMATIC MODE"
    // where the transition from open loop to sensorless in performed automaticaly
    // Selecting 1 will enable the "USER mode"
    // where user decide whether to switch to force mode, tracking mode, sensorless mode
    if (cntrState.usrControl.controlMode == automatic)
    {
        if (pos_mode == linkup)
        {
            if (LinkupDuration == 0)
            {
                pos_mode = sensorless1;
            }
        }
        else
        {
            automaticMode();
        }
    }

    // user decide whether to switch to force mode, tracking mode, sensorless mode
    switch (pos_mode)
    {
    case force:
        drvFOC.speedPI.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
        drvFOC.speedPI.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedPI.f16UpperLimit);

        drvFOC.pospeControl.thRotEl = drvFOC.pospeOpenLoop.thRotEl;
        drvFOC.pospeControl.wRotEl = 0;

        ////+ by phidia.wang 20180920
        drvFOC.speedPI.f16PropGain = FRAC16(0.82279808);  //SPEED_PI_PROP_GAIN;
        drvFOC.speedPI.s16PropGainShift = 4;              //SPEED_PI_PROP_SHIFT
        drvFOC.speedPI.f16IntegGain = FRAC16(0.52659077); //SPEED_PI_INTEG_GAIN
        drvFOC.speedPI.s16IntegGainShift = -1;            //SPEED_PI_INTEG_SHIFT
                                                          //drvFOC.speedPI.f32IntegPartK_1         = 0;
                                                          //drvFOC.speedPI.f16UpperLimit           = FRAC16(8.0/I_MAX);
                                                          //drvFOC.speedPI.f16LowerLimit           = FRAC16(-8.0/I_MAX);

        //OL_SpeedRampInc = OL_START_RAMP_INC;
        if ((drvFOC.pospeOpenLoop.wRotEl >= FRAC16(20.0 / N_MAX)) && (OL_SpeedRampInc < OL_START_RAMP_INC * 5)) //TimerOLRampCNT >= 3000
        {
            OL_SpeedRampInc += 20;
            //TimerOLRampCNT = 2000;
        }
        else
        {
            OL_SpeedRampInc = OL_START_RAMP_INC;
        }
        ////////////////////////////////////////////////////////////////

        drvFOC.speedRampPos.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampPos.f32RampDown = OL_SpeedRampInc;

        drvFOC.speedRampNeg.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampNeg.f32RampDown = OL_SpeedRampInc;

        drvFOC.pospeSensorless.wRotEl = 0;
        drvFOC.pospeSensorless.thRotEl = 0;

        AMCLIB_BemfObsrvDQInit_F16(&drvFOC.pospeSensorless.bEMFObs);

        drvFOC.pospeSensorless.TrackObsrv.pParamPI.f32Acc = ((tFrac32)drvFOC.pospeOpenLoop.wRotEl << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift));
        drvFOC.pospeSensorless.filterMA.f32Acc = ((tFrac32)drvFOC.pospeOpenLoop.wRotEl << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift));
        drvFOC.pospeSensorless.TrackObsrv.pParamInteg.f32State = ((tFrac32)(drvFOC.pospeOpenLoop.thRotEl) << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamInteg.u16NShift));
        break;
    case tracking:
        drvFOC.speedPI.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
        drvFOC.speedPI.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedPI.f16UpperLimit);

        drvFOC.pospeControl.thRotEl = drvFOC.pospeOpenLoop.thRotEl;
        drvFOC.pospeControl.wRotEl = 0;

        ////+ by phidia.wang 20180920
        drvFOC.speedPI.f16PropGain = SPEED_PI_PROP_GAIN;
        drvFOC.speedPI.s16PropGainShift = SPEED_PI_PROP_SHIFT;
        drvFOC.speedPI.f16IntegGain = SPEED_PI_INTEG_GAIN;
        drvFOC.speedPI.s16IntegGainShift = SPEED_PI_INTEG_SHIFT;
        //drvFOC.speedPI.f32IntegPartK_1         = 0;
        //drvFOC.speedPI.f16UpperLimit           = SPEED_LOOP_HIGH_LIMIT;
        //drvFOC.speedPI.f16LowerLimit           = SPEED_LOOP_LOW_LIMIT;

        OL_SpeedRampInc = OL_START_RAMP_INC * 5; //+ by phidia.wang 20180920
        ////////////////////////////////////////////////////
        drvFOC.speedRampPos.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampPos.f32RampDown = OL_SpeedRampInc;

        drvFOC.speedRampNeg.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampNeg.f32RampDown = OL_SpeedRampInc;
        break;
    case linkup: //waiting calculation of the Bemf Observer
        drvFOC.speedPI.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
        drvFOC.speedPI.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedPI.f16UpperLimit);

        drvFOC.pospeControl.thRotEl = drvFOC.pospeOpenLoop.thRotEl;
        drvFOC.pospeControl.wRotEl = 0;

        ////+ by phidia.wang 20180920
        drvFOC.speedPI.f16PropGain = SPEED_PI_PROP_GAIN;
        drvFOC.speedPI.s16PropGainShift = SPEED_PI_PROP_SHIFT;
        drvFOC.speedPI.f16IntegGain = SPEED_PI_INTEG_GAIN;
        drvFOC.speedPI.s16IntegGainShift = SPEED_PI_INTEG_SHIFT;
        //drvFOC.speedPI.f32IntegPartK_1         = 0;
        //drvFOC.speedPI.f16UpperLimit           = SPEED_LOOP_HIGH_LIMIT;
        //drvFOC.speedPI.f16LowerLimit           = SPEED_LOOP_LOW_LIMIT;

        OL_SpeedRampInc = OL_START_RAMP_INC; //+ by phidia.wang 201801015
        ////////////////////////////////////////////////////
        drvFOC.speedRampPos.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampPos.f32RampDown = OL_SpeedRampInc;

        drvFOC.speedRampNeg.f32RampUp = OL_SpeedRampInc;
        drvFOC.speedRampNeg.f32RampDown = OL_SpeedRampInc;
        break;
    case sensorless1:
        drvFOC.speedPI.f16UpperLimit = drvFOC.pospeSensorless.iQUpperLimit;
        drvFOC.speedPI.f16LowerLimit = drvFOC.pospeSensorless.iQLowerLimit;

        drvFOC.pospeControl.thRotEl = drvFOC.pospeSensorless.thRotEl;
        drvFOC.pospeControl.wRotEl = drvFOC.pospeSensorless.wRotEl;

        ////+ by phidia.wang 20180920
        if (drvFOC.speedPI.f16UpperLimit < SPEED_LOOP_HIGH_LIMIT)
            drvFOC.speedPI.f16UpperLimit += 1;
        drvFOC.speedPI.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedPI.f16UpperLimit);
        //drvFOC.speedPI.f16UpperLimit           = SPEED_LOOP_HIGH_LIMIT;
        //drvFOC.speedPI.f16LowerLimit           = SPEED_LOOP_LOW_LIMIT;
        /////////////////////////////////////////////////////////
        drvFOC.speedRampPos.f32RampUp = CL_SpeedRampInc;
        drvFOC.speedRampPos.f32RampDown = CL_SpeedRampDec;

        drvFOC.speedRampNeg.f32RampUp = CL_SpeedRampDec;
        drvFOC.speedRampNeg.f32RampDown = CL_SpeedRampInc;

        drvFOC.pospeOpenLoop.integ.f32State = ((tFrac32)(drvFOC.pospeSensorless.thRotEl) << (16 + drvFOC.pospeOpenLoop.integ.u16NShift));
        break;
    }

    /*-----------------------------------------------------
	    Calculate Field Oriented Control FOC
	----------------------------------------------------- */
    if (++drvFOC.pospeControl.speedLoopCntr >= SPEED_LOOP_CNTR)
    {
        drvFOC.pospeControl.speedLoopCntr = 0;

        if (!cntrState.usrControl.btSpeedUp)
            drvFOC.pospeControl.wRotElReq = MLIB_AddSat_F16(drvFOC.pospeControl.wRotElReq, FRAC16(1.0 / WEL_MAX));

        if (!cntrState.usrControl.btSpeedDown)
            drvFOC.pospeControl.wRotElReq = MLIB_SubSat_F16(drvFOC.pospeControl.wRotElReq, FRAC16(1.0 / WEL_MAX));

        stateRunStatus = focSlowLoop();
        if (!stateRunStatus)
        {
            tempfaults.stateMachine.B.RunError = 1;
        }
    }

    stateRunStatus = focFastLoop();

    if (!stateRunStatus)
    {
        tempfaults.stateMachine.B.RunError = 1;
    }

    SetDutycycle(&drvFOC.pwm16, drvFOC.svmSector);

    //PTT_PTT0 = 0;		// Clear debug pin to record execution time
}

/*****************************************************************************
*
* Function: void stateCheckM(void)
*
* Description:  pCheckMotorRunning
*
*****************************************************************************/
void stateCheckM()
{
    //static tBool stateCheckStatus;
    //stateCheckStatus = false;

   cntrState.state = checkM;
   cntrState.event = e_check;

   if (RunningChk_counter > 500) ///500ms
   {
       if (control_flags.ROTATION_CHECK == FALSE) ////如果500ms还没检测到旋转，则进入静止启动程序
       {
           AppBrakeToAlignment();
       }
       else ////如果检测到自由旋转的速度太快，则重新检测500ms
       {
           RunningChk_counter = 0;
           control_flags.ROTATION_CHECK = FALSE;
       }
   }
}

/***************************************************************************/ /*!
*
* @brief   RUN Brake sub-state
*
* @param   void
*
* @return  none
*
******************************************************************************/
void stateBrake()
{
    cntrState.state = brake;
    cntrState.event = e_brake;
    //DCBusCurrentFiltered = (tFrac16)((long) ((long)DCBusCurrentFiltered + (long)DCBusCurrentFiltered + (long)DCBusCurrentFiltered + (long)DCBusCurrent) >> 2);
    /* save the max phase current */
    //if (DCBusCurrentMAX < DCBusCurrentFiltered)
    //DCBusCurrentMAX = DCBusCurrentFiltered;

    /* slow control loop */
    if ((BrakeLoopDuration == 0))
    {
        BrakeLoopDuration = 2000; ///100ms
        brakeEnableFlags = 0;
        //AppBrakeToAlignment();
        /* 
		// keep phase current in reasonable range during breaking //
		  if (DCBusCurrentMAX < FRAC16(2.0/DC_BUS_CURRENT_MAX) )///max current=20A
		  {
			  // if amplitude of phase current is less then 0.5% of nominal current , 
			  // stop the motor by applying zero duty cycle     //
			  duty_cycle += 125;//MLIB_Mul(PIOut, PWM_MODULO, F16);    // duty cycle 0-1 -> 0-PWM_MODULO
			  if(duty_cycle > PWM_MODULO)
			  {
				  duty_cycle = PWM_MODULO;				  
			  }
			  UpdateDutycycle();
			  
			  if(DCBusCurrentMAX < FRAC16(0.2/DC_BUS_CURRENT_MAX))
			  {
				  brakeEnableFlags = 0;					  
			  }
			  //M1_TransRunBrakeCalib();  
			  
		  }
		  else // wait till motor stops 
		  {

		  }
		  DCBusCurrentMAX = 0; // zero the max current variable before next periode of current evaluation //				   
		*/
    }
}

/***************************************************************************/ /*!
*
* @brief   Field Oriented Control - slow loop calculations
*
* @param   
*
* @return  none
*
******************************************************************************/
static tBool focSlowLoop()
{
    if (cntrState.usrControl.FOCcontrolMode != speedControl)
    {
        // required speed for open loop start-up in sensorless mode = MERG_SPEED_1_TRH*1,5
        //wRotElReq = MERG_SPEED_1_TRH * 9.55 * 1.5 / pp = MERG_SPEED_1_TRH * 4.775 = ((MERG_SPEED_1_TRH*Frac16(0.596875)) << 3;
        if (cntrState.usrControl.FOCcontrolMode == voltageControl && drvFOC.uDQReq.f16Arg2 == 0)
            drvFOC.pospeControl.wRotElReq = 0;
        else if (cntrState.usrControl.FOCcontrolMode == currentControl && drvFOC.iDQReq.f16Arg2 == 0)
            drvFOC.pospeControl.wRotElReq = 0;
        else if (cntrState.usrControl.FOCcontrolMode != scalarControl)
            drvFOC.pospeControl.wRotElReq = MLIB_ShL_F16(MLIB_Mul_F16(FRAC16(0.75), MERG_SPEED_1_TRH), 1);
    }

    if (drvFOC.pospeControl.wRotElReqRamp >= 0)
        drvFOC.pospeControl.wRotElReqRamp = (tFrac16)(GFLIB_Ramp_F32(((tFrac32)drvFOC.pospeControl.wRotElReq) << 16, &drvFOC.speedRampPos) >> 16);
    else
        drvFOC.pospeControl.wRotElReqRamp = (tFrac16)(GFLIB_Ramp_F32(((tFrac32)drvFOC.pospeControl.wRotElReq) << 16, &drvFOC.speedRampNeg) >> 16);

    if (drvFOC.pospeControl.wRotElReqRamp > FRAC16(0.95))
        drvFOC.pospeControl.wRotElReqRamp = FRAC16(0.95);
    if (drvFOC.pospeControl.wRotElReqRamp < FRAC16(-0.95))
        drvFOC.pospeControl.wRotElReqRamp = FRAC16(-0.95);

    drvFOC.pospeControl.wRotEl = GDFLIB_FilterMA_F16(drvFOC.pospeControl.wRotEl, &drvFOC.pospeControl.wRotFilter);

    drvFOC.pospeControl.wRotElErr = MLIB_SubSat(drvFOC.pospeControl.wRotElReqRamp, drvFOC.pospeControl.wRotEl);

    // Speed FO control mode
    if (cntrState.usrControl.FOCcontrolMode == speedControl)
        drvFOC.iDQReq.f16Arg2 = GFLIB_ControllerPIpAW(drvFOC.pospeControl.wRotElErr, &drvFOC.speedPI);

    return true;
}

/***************************************************************************/ /*!
*
* @brief   Field Oriented Control - fast loop calculations
*
* @param   
*
* @return  none
*
******************************************************************************/
volatile unsigned int dPI = 1, qPI = 1;
static tBool focFastLoop()
{
    GMCLIB_Clark(&drvFOC.iAlBeFbck, &drvFOC.iAbcFbck);

    // Scalar control mode
    if (cntrState.usrControl.FOCcontrolMode == scalarControl)
    {
        // generated electrical position for scalar control purpose

        // Required voltage = VHzRatio * Required Frequency
        drvFOC.scalarControl.UmReq = MLIB_ShL_F16(MLIB_Mul(drvFOC.scalarControl.VHzRatioReq, drvFOC.pospeControl.wRotElReqRamp), drvFOC.scalarControl.VHzRatioReq_Shift);

        // thRotEl is calculated in CalcOpenLoop executed in focSlowLoop
        drvFOC.thTransform.f16Arg1 = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
        drvFOC.thTransform.f16Arg2 = GFLIB_Cos(drvFOC.pospeControl.thRotEl);

        drvFOC.uDQReq.f16Arg1 = 0;
        drvFOC.uDQReq.f16Arg2 = drvFOC.scalarControl.UmReq;

        // enable Bemf observer
        cntrState.usrControl.controlMode = manual;
        pos_mode = tracking;
    }

    // DQ Voltage FO control mode
    if (cntrState.usrControl.FOCcontrolMode == voltageControl)
    {
        if (drvFOC.uDQReq.f16Arg2 != 0)
        {
            drvFOC.thTransform.f16Arg1 = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
            drvFOC.thTransform.f16Arg2 = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
        }
        else
        {
            drvFOC.thTransform.f16Arg1 = 0;
            drvFOC.thTransform.f16Arg2 = FRAC16(FRACT_MAX);
        }

        GMCLIB_Park(&drvFOC.iDQFbck, &drvFOC.thTransform, &drvFOC.iAlBeFbck);
    }

    // DQ Current and Speed FO control mode
    if (cntrState.usrControl.FOCcontrolMode == currentControl || cntrState.usrControl.FOCcontrolMode == speedControl)
    {
        if (cntrState.usrControl.FOCcontrolMode == speedControl)
        {
            drvFOC.thTransform.f16Arg1 = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
            drvFOC.thTransform.f16Arg2 = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
        }
        else
        {
            if (drvFOC.iDQReq.f16Arg2 != 0)
            {
                drvFOC.thTransform.f16Arg1 = 0;
                drvFOC.thTransform.f16Arg2 = FRAC16(FRACT_MAX);
            }
            else
            {
                drvFOC.thTransform.f16Arg1 = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
                drvFOC.thTransform.f16Arg2 = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
            }
        }

        GMCLIB_Park(&drvFOC.iDQFbck, &drvFOC.thTransform, &drvFOC.iAlBeFbck);

        drvFOC.iDQErr.f16Arg1 = MLIB_SubSat(drvFOC.iDQReq.f16Arg1, drvFOC.iDQFbck.f16Arg1);
        drvFOC.iDQErr.f16Arg2 = MLIB_SubSat(drvFOC.iDQReq.f16Arg2, drvFOC.iDQFbck.f16Arg2);

        // 90% of available DCbus recalculated to phase voltage = 0.90*uDCB/sqrt(3)
        drvFOC.dAxisPI.f16UpperLimit = GFLIB_Limit_F16((tFrac16)((MLIB_Mul_F32F16F16(FRAC16(0.54848), drvFOC.f16Udcb)) >> 16), &drvFOC.iCLoop_Limit);
        drvFOC.dAxisPI.f16LowerLimit = MLIB_Neg(drvFOC.dAxisPI.f16UpperLimit);

        if (dPI)
        {
            drvFOC.uDQReq.f16Arg1 = GFLIB_ControllerPIrAW(drvFOC.iDQErr.f16Arg1, &drvFOC.dAxisPI);
        }

        // Voltage limit
        drvFOC.qAxisPI.f16UpperLimit = GFLIB_Limit_F16(GFLIB_Sqrt(MLIB_SubSat_F16(
                                                           MLIB_Mul_F16(drvFOC.dAxisPI.f16UpperLimit, drvFOC.dAxisPI.f16UpperLimit),
                                                           MLIB_Mul_F16(drvFOC.uDQReq.f16Arg1, drvFOC.uDQReq.f16Arg1))),
                                                       &drvFOC.iCLoop_Limit);
        drvFOC.qAxisPI.f16LowerLimit = MLIB_Neg(drvFOC.qAxisPI.f16UpperLimit);

        if (qPI)
        {
            drvFOC.uDQReq.f16Arg2 = GFLIB_ControllerPIrAW(drvFOC.iDQErr.f16Arg2, &drvFOC.qAxisPI);
        }
    }
    //////////////////////////////////////

    GMCLIB_ParkInv(&drvFOC.uAlBeReq, &drvFOC.thTransform, &drvFOC.uDQReq);

    drvFOC.elimDcbRip.f16ArgDcBusMsr = meas.measured.f16Udcb.filt;
    GMCLIB_ElimDcBusRip(&drvFOC.uAlBeReqDCB, &drvFOC.uAlBeReq, &drvFOC.elimDcbRip);

    drvFOC.svmSector = GMCLIB_SvmStd(&(drvFOC.pwm16), &drvFOC.uAlBeReqDCB);

    return (true);
}

/***************************************************************************/ /*!
*
* @brief   Fault Detection function
*
* @param   none
*
* @return  none
*
******************************************************************************/
static tBool faultDetection()
{
    tBool faultDetectiontEvent;

    faultDetectiontEvent = false;

    //-----------------------------
    // Actual Faults
    //-----------------------------
    /*
    // TRIP:   Phase A over-current detected
	tempfaults.motor.B.OverPhaseACurrent = (drvFOC.iAbcFbck.f16Arg1 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;

	// TRIP:   Phase B over-current detected
	tempfaults.motor.B.OverPhaseBCurrent = (drvFOC.iAbcFbck.f16Arg2 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;

	// TRIP:   Phase C over-current detected
	tempfaults.motor.B.OverPhaseCCurrent = (drvFOC.iAbcFbck.f16Arg3 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;

	// TRIP:   DC-bus over-voltage
	tempfaults.motor.B.OverDCBusVoltage  = (meas.measured.f16Udcb.raw > U_DCB_TRIP) ? true : false;

	// TRIP:   DC-bus under-voltage
	tempfaults.motor.B.UnderDCBusVoltage = (meas.measured.f16Udcb.raw < MLIB_Div_F16(U_DCB_UNDERVOLTAGE,FRAC16(0.91))) ? true : false;
	
	// Fault:   Over temperature
	tempfaults.motor.B.OverHeating   	   = (meas.measured.f16Temp.filt > MLIB_Mul_F16(TEMP_OVER,FRAC16(0.9))) ? true : false;

	//-----------------------------
	// Pending Faults
	//-----------------------------

	if (cntrState.state != fault)
	{
		// Fault:   Phase A over-current detected
		permFaults.motor.B.OverPhaseACurrent   = (drvFOC.iAbcFbck.f16Arg1 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseACurrent;

		// Fault:   Phase B over-current detected
		permFaults.motor.B.OverPhaseBCurrent   = (drvFOC.iAbcFbck.f16Arg2 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseBCurrent;

		// Fault:   Phase C over-current detected
		permFaults.motor.B.OverPhaseCCurrent   = (drvFOC.iAbcFbck.f16Arg3 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseCCurrent;

		// Fault:   DC-bus over-voltage
		permFaults.motor.B.OverDCBusVoltage    = (meas.measured.f16Udcb.raw > U_DCB_OVERVOLTAGE) ? true : permFaults.motor.B.OverDCBusVoltage;

		// Fault:   DC-bus under-voltage
		permFaults.motor.B.UnderDCBusVoltage   = (meas.measured.f16Udcb.raw < U_DCB_UNDERVOLTAGE) ? true : permFaults.motor.B.UnderDCBusVoltage;

		// Fault:   Over temperature
		permFaults.motor.B.OverHeating   	   = (meas.measured.f16Temp.filt > TEMP_OVER) ? true : permFaults.motor.B.OverHeating;
		
		permFaults.mcu.B.GDU_Error = GetDriverError();
		permFaults.mcu.B.PWM_Error = GetPMF_Faults();
		permFaults.mcu.B.PTU_Error = GetPTU_Errors();
	}
*/

    permFaults.mcu.B.GDU_Error = GetDriverError();
    if (permFaults.mcu.B.GDU_Error != 0)
        mcFaultSource = FaultGDUerror;
    permFaults.mcu.B.PWM_Error = GetPMF_Faults();
    if (permFaults.mcu.B.PWM_Error != 0)
        mcFaultSource = FaultPMFerror;
    permFaults.mcu.B.PTU_Error = GetPTU_Errors();
    if (permFaults.mcu.B.PTU_Error != 0)
        mcFaultSource = FaultPTUerror;

    mcDcbusFlt = drvFOC.f16Udcb;
    mcSpeedFlt = (drvFOC.pospeSensorless.wRotEl); //MLIB_AbsSat_F16
    mcEsValue = MLIB_AbsSat_F16(drvFOC.pospeSensorless.bEMFObs.pEObsrv.f16Arg2);

    User_Fault_Detection();

    if ((permFaults.motor.R != 0x0))
        faultDetectiontEvent = true;
    if ((permFaults.mcu.R != 0x0))
        faultDetectiontEvent = true;
    if ((permFaults.stateMachine.R != 0x0))
        faultDetectiontEvent = true;

    return faultDetectiontEvent;
}

/***************************************************************************/ /*!
*
* @brief   Open loop generator of open loop position and speed
*
* @param   pointer to structure of openLoopPospe_t type
* @param   speed ramp
*
* @return  none
*
******************************************************************************/
static tBool CalcOpenLoop(openLoopPospe_t *openLoop, tFrac16 speedReqRamp)
{
    openLoop->wRotEl = speedReqRamp;
    openLoop->thRotEl = GFLIB_IntegratorTR_F16(speedReqRamp, &openLoop->integ);
    return (true);
}

/***************************************************************************/ /*!
*
* @brief   Calculate Position and Speed In Sensorless Mode
*
* @param   none
*
* @return  bool
*
******************************************************************************/
tBool automaticMode()
{
    if (MLIB_Abs_F16(drvFOC.pospeOpenLoop.wRotEl) < drvFOC.pospeSensorless.wRotElMatch_1)
    {
        pos_mode = force;
    }
    else if (MLIB_Abs_F16(drvFOC.pospeOpenLoop.wRotEl) >= drvFOC.pospeSensorless.wRotElMatch_1 &&
             MLIB_Abs_F16(drvFOC.pospeOpenLoop.wRotEl) < drvFOC.pospeSensorless.wRotElMatch_2)
    {
        pos_mode = tracking;
    }
    else
    {
        pos_mode = sensorless1;
    }

    return (true);
}

/* LED application control*/
/***************************************************************************/ /*!
*
* @brief   LED OFF state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateLedOFF()
{
    PTS_PTS4 = 0;
}

/***************************************************************************/ /*!
*
* @brief   LED ON state
*
* @param   
* 
* @return  none
*
******************************************************************************/
void stateLedON()
{
    PTS_PTS4 = 1;
}

/***************************************************************************/ /*!
*
* @brief   LED FLASHING state
*
* @param    
* 
* @return  none
*
******************************************************************************/
void stateLedFLASHING_SLOW()
{
    cntrState.usrControl.ledCounter += 1;

    if ((cntrState.usrControl.ledCounter) > ((cntrState.usrControl.ledFlashing) << 1))
    {
        PTS_PTS4 ^= 1;
        cntrState.usrControl.ledCounter = 0;
    }
}

/***************************************************************************/ /*!
*
* @brief   LED FLASHING state
*
* @param    
* 
* @return  none
*
******************************************************************************/
void stateLedFLASHING_FASTER()
{
    cntrState.usrControl.ledCounter += 1;

    if ((cntrState.usrControl.ledCounter) > ((cntrState.usrControl.ledFlashing >> 1) << 1))
    {
        PTS_PTS4 ^= 1;
        cntrState.usrControl.ledCounter = 0;
    }
}

/***************************************************************************/ /*!
*
* @brief   LED FLASHING state
*
* @param    
*
* @return  none
*
******************************************************************************/
void stateLedFLASHING_FAST()
{
    cntrState.usrControl.ledCounter += 1;

    if ((cntrState.usrControl.ledCounter) > ((cntrState.usrControl.ledFlashing) >> 1))
    {
        PTS_PTS4 ^= 1;
        cntrState.usrControl.ledCounter = 0;
    }
}

/***************************************************************************/ /*!
*
* @brief   measure motor BEMF,and check motor running 
*
* @param    
*
* @return  none
*
******************************************************************************/
void Motor_TailWind(void)
{
   //cntrState.state = APP_CHECKMOTOR;
   if ((cntrState.state == checkM)) //||(cntrState.state == APP_STOP)
   {
       timeBEMF = TIM0TCNT;
       phaseVoltage = ADC1ResultList[0][2] >> 1; //measure motor bemf
       switch (ADC_channel)                      //read result and change ADC_CH
       {
       case VPH_CH_RED:
           vph_red = phaseVoltage;
           ADC_channel = VPH_CH_YELLOW;
           break;

       case VPH_CH_YELLOW:
           vph_yellow = phaseVoltage;
           ADC_channel = VPH_CH_BLUE;
           break;

       case VPH_CH_BLUE:
           vph_blue = phaseVoltage;
           ADC_channel = VPH_CH_RED;
           break;

       default:
           ADC_channel = VPH_CH_RED;
           break;
       }

       //PTUTriggerEventList[1][0][0] = MIN_ADC_TRIGGER_SECOND;// ADC1 - phase voltage
       GDUPHMUX_GPHMX = ADC_channel; // will be applied at the next PMF Reload
       PTUC_PTULDOK = 1;
       CheckMotorRunning(); //check motor running
   }
}

void CheckMotorRunning(void)
{
   static unsigned int previous_vph_red;
   static unsigned int previous_vph_yellow;
   static unsigned int previous_vph_blue;

   static unsigned char level_count_red;
   static unsigned char level_count_yellow;
   static unsigned char level_count_blue;

   static unsigned int previous_edge_time;
   static unsigned char retry_counter;

   unsigned int new_edge_time;
   unsigned int one_twenty_deg;
   //unsigned int thirty_deg;

   //control_flags.INIT_ACQUIRE=TRUE;
   if (control_flags.INIT_ACQUIRE == TRUE)
   {
       control_flags.INIT_ACQUIRE = FALSE;
       control_flags.ACQUIRE_RED = FALSE;
       control_flags.ACQUIRE_YELLOW = FALSE;
       control_flags.ACQUIRE_BLUE = FALSE;
       previous_vph_red = 0;
       previous_vph_yellow = 0;
       previous_vph_blue = 0;
       level_count_red = 0;
       level_count_yellow = 0;
       level_count_blue = 0;
       previous_edge_time = 0;
       if (control_flags.RETRY_FLAG == FALSE)
           retry_counter = NO_RETRIES;
       control_flags.WINDMILLING = FALSE;

       return;
   }
   // Check for failure to acquire by monitoring retry counter
   // The retry counter is loaded first time acqusition starts
   // Every time same phase is detected as rising before another phase
   // the counter is decremented.
   // If the retry counter has reached zero and no other trip exists
   if ((retry_counter == 0))
   {
       if ((vph_red < VPH_THRESHOLD * 6) || (vph_red < VPH_THRESHOLD * 6) || (vph_red < VPH_THRESHOLD * 6))
       {
           BrakeLoopDuration = 1000;
           AppTranToBrake();
       }
       else
           permFaults.motor.B.FaultChkMotor = 1; //driveStatus.bit.Fault = 1;

       return;
   }
   // Note that all three sections of code below are similar in function but
   // differ according to the particular sectors, directions etc
   // Red phase code is fully commented, Yellow and Blue are not

   /******************** START OF RED PHASE CODE **********************************/

   // To provide robust crossing detection, a similar scheme as used for zero
   // crossing is used except need a separate counter for each phase.
   // The level counter is only incremented if we see VPH below the acquire_threshold
   // and it has not reached the level_threshold. We are looking for a rising edge
   //VPH_THRESHOLD //
   if ((vph_red < VPH_THRESHOLD) && (level_count_red < LEVEL_COUNT))
   {
       level_count_red++;
   }

   // If we have seen sufficient samples below the acquire_threshold
   if (level_count_red == LEVEL_COUNT)
   {
       // If previous sample and current sample are >= acquire_threshold
       // then we treat this as a valid rising edge
       if ((previous_vph_red >= VPH_THRESHOLD) && (vph_red >= VPH_THRESHOLD))
       {
           // Grab new timestamp from free-running counter (Read in PTU1ISR)
           //CURRENT_LIMIT_LED = 1;
           new_edge_time = timeBEMF;
           // If ACQUIRE_RED is already set this means that have two edges
           // of RED before another phase which is not correct
           // If detected then reinitialize acquision and decrement retry_counter
           if (control_flags.ACQUIRE_RED)
           {
               // The RETRY_FLAG is set so initialization code does not reload
               // the retry_counter
               control_flags.RETRY_FLAG = TRUE;
               if (retry_counter)
                   retry_counter--;
               // Setting this flag will force re-initialization next call
               control_flags.INIT_ACQUIRE = TRUE;
               return;
           }
           // Reset level_counter so that VPH has to fall back beneath
           // acquire_threshold before rising check done again.
           level_count_red = 0;

           //RunningChk_counter = 0;
           // Now check to see if a previous phase's rising edge has already
           // detected. The sequence of the rising edges determines direction
           // and therefore also which sector has just been entered.
           if (control_flags.ACQUIRE_BLUE == TRUE)
           {
               // Update the sector that rotor is in
               //sector=5;
               NextCmtSector = 5;
               ActualCmtSector = NextCmtSector;

               // Calculate times for 120 and 30 electrical degrees
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg>>2;

               // Calculate period measurement so speed loop has valid data
               // and ensure don't try to re-acquire at too high a speed.
               // The period measurement is 360 electrical degrees
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);

               // Check to see if windmilling i.e. motor is turning in opposite
               // direction to demanded direction.
               if (control_flags.DIR == BACKWARDS) // If windmilling
               {
                   // Set WINDMILLING flag so that starting code enters brake state
                   control_flags.WINDMILLING = TRUE;
                   // Clear ROTATION_CHECK flag as valid rotation is occuring
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = FORWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   control_flags.ACQUIRE_RED = FALSE;
                   control_flags.ACQUIRE_YELLOW = FALSE;
                   control_flags.ACQUIRE_BLUE = FALSE;
                   if (actualSpeed > (CHECK_MIN_SPEED))
                       BrakeLoopDuration = 2000; ////Brake time:2S
                   else
                       BrakeLoopDuration = 1000; ////Brake time:1S

                   AppTranToBrake();
                   return;
               }

               // To reach this section of code motor not windmilling and have detected a
               // second valid rising edge and so ought to be able to launch sensorless.
               // However, if going too fast, sensorless will get immediately lost due
               // to enevitable error in threshold detection and because there may
               // not be time for sufficient samples of VPH to catch the zero crossing

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK to run sensorless//REACQUIRE_THRESHOLD
               {
                   // To ensure sensorless can pick straight up need to
                   // extrapolate backwards in time and set up previous timestamps
                   NextCmtPeriod = one_twenty_deg / 2;
                   duty_cycle = 0; ///duty = 10%;
                   //AppFreewheelToRun();
                   AppTranToBrake();
               }
               else // Going too fast to re-acquire
               {
                   // Force re-start of acqusition
                   control_flags.INIT_ACQUIRE = TRUE;
                   //CURRENT_LIMIT_LED = 1;
                   // Also set ROTATION_CHECK flag
                   control_flags.ROTATION_CHECK = TRUE;
               }
               return;
           }

           if (control_flags.ACQUIRE_YELLOW == TRUE)
           {
               NextCmtSector = 2;
               ActualCmtSector = NextCmtSector;
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg>>2;
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);
               //stall_counter=0;
               if (control_flags.DIR == FORWARDS) // If windmilling
               {
                   control_flags.WINDMILLING = TRUE;
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = BACKWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   control_flags.ACQUIRE_RED = FALSE;
                   control_flags.ACQUIRE_YELLOW = FALSE;
                   control_flags.ACQUIRE_BLUE = FALSE;
                   if (actualSpeed > CHECK_MIN_SPEED)
                       BrakeLoopDuration = 2000;
                   else
                       BrakeLoopDuration = 1000;

                   AppTranToBrake();
                   return;
               }

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK, to run sensorless
               {
                   NextCmtPeriod = one_twenty_deg / 2;
                   duty_cycle = 0; ///duty = 10%;
                   //AppFreewheelToRun();
               }
               else
               {
                   control_flags.INIT_ACQUIRE = TRUE;
                   control_flags.ROTATION_CHECK = TRUE;
                   //CURRENT_LIMIT_LED = 1;
               }
               return;
           }
           // Save timestamp just taken as it will be required when second rising
           // edge is detected to work out period etc.
           previous_edge_time = new_edge_time;
           // Set flag to indicate a valid rising edge has been detected on this phase
           control_flags.ACQUIRE_RED = TRUE;
       }
   }
   /********************* END OF RED PHASE CODE *****************************************/

   /********************START OF YELLOW PHASE CODE **************************************/
   if ((vph_yellow < VPH_THRESHOLD) && (level_count_yellow < LEVEL_COUNT))
   {
       level_count_yellow++;
   }

   if (level_count_yellow == LEVEL_COUNT)
   {
       if ((previous_vph_yellow >= VPH_THRESHOLD) && (vph_yellow >= VPH_THRESHOLD))
       {
           new_edge_time = timeBEMF;
           //CURRENT_LIMIT_LED = 1;
           if (control_flags.ACQUIRE_YELLOW)
           {

               control_flags.RETRY_FLAG = TRUE;
               if (retry_counter)
                   retry_counter--;
               control_flags.INIT_ACQUIRE = TRUE;
               return;
           }

           level_count_yellow = 0;
           //RunningChk_counter = 0;
           if (control_flags.ACQUIRE_RED == TRUE)
           {
               NextCmtSector = 1;
               ActualCmtSector = NextCmtSector;
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg/4;
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);

               if (control_flags.DIR == BACKWARDS)
               {
                   control_flags.WINDMILLING = TRUE;
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = FORWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   if (actualSpeed > CHECK_MIN_SPEED)
                       BrakeLoopDuration = 2000;
                   else
                       BrakeLoopDuration = 1000;
                   AppTranToBrake();
                   return;
               }

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK to run sensorless
               {
                   NextCmtPeriod = one_twenty_deg / 2;
                   //duty_cycle = 0;///duty = 10%;
                   //AppFreewheelToRun();
               }
               else
               {
                   control_flags.INIT_ACQUIRE = TRUE;
                   control_flags.ROTATION_CHECK = TRUE;
                   //CURRENT_LIMIT_LED = 1;
               }
               return;
           }

           if (control_flags.ACQUIRE_BLUE == TRUE)
           {
               NextCmtSector = 4;
               ActualCmtSector = NextCmtSector;
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg/4;
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);

               if (control_flags.DIR == FORWARDS)
               {
                   control_flags.WINDMILLING = TRUE;
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = BACKWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   if (actualSpeed > CHECK_MIN_SPEED)
                       BrakeLoopDuration = 2000;
                   else
                       BrakeLoopDuration = 1000;
                   AppTranToBrake();
                   return;
               }

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK to run sensorless
               {
                   NextCmtPeriod = one_twenty_deg / 2;
                   duty_cycle = 0; ///duty = 10%;
                   //AppFreewheelToRun();
               }
               else
               {
                   control_flags.INIT_ACQUIRE = TRUE;
                   control_flags.ROTATION_CHECK = TRUE;
                   //CURRENT_LIMIT_LED = 1;
               }
               return;
           }
           previous_edge_time = new_edge_time;
           control_flags.ACQUIRE_YELLOW = TRUE;
       }
   }
   /********************* END OF YELLOW PHASE CODE **********************************/

   /**********************START OF BLUE PHASE CODE **********************************/

   if ((vph_blue < VPH_THRESHOLD) && (level_count_blue < LEVEL_COUNT))
   {
       level_count_blue++;
   }

   if (level_count_blue == LEVEL_COUNT)
   {
       if ((previous_vph_blue >= VPH_THRESHOLD) && (vph_blue >= VPH_THRESHOLD))
       {
           new_edge_time = timeBEMF;
           //CURRENT_LIMIT_LED = 1;
           if (control_flags.ACQUIRE_BLUE)
           {

               control_flags.RETRY_FLAG = TRUE;
               if (retry_counter)
                   retry_counter--;
               control_flags.INIT_ACQUIRE = TRUE;
               return;
           }

           level_count_blue = 0;
           //RunningChk_counter = 0;
           if (control_flags.ACQUIRE_YELLOW == TRUE)
           {
               //sector=3;
               NextCmtSector = 3;
               ActualCmtSector = NextCmtSector;
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg/4;
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);

               if (control_flags.DIR == BACKWARDS)
               {
                   control_flags.WINDMILLING = TRUE;
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = FORWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   if (actualSpeed > CHECK_MIN_SPEED)
                       BrakeLoopDuration = 2000;
                   else
                       BrakeLoopDuration = 1000;
                   AppTranToBrake();
                   return;
               }

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK to run sensorless
               {
                   NextCmtPeriod = one_twenty_deg / 2;
                   duty_cycle = 0; ///duty = 10%;
                   //AppFreewheelToRun();
               }
               else
               {
                   control_flags.INIT_ACQUIRE = TRUE;
                   control_flags.ROTATION_CHECK = TRUE;
                   //CURRENT_LIMIT_LED = 1;
               }
               return;
           }

           if (control_flags.ACQUIRE_RED == TRUE)
           {
               //sector=0;
               NextCmtSector = 0;
               ActualCmtSector = NextCmtSector;
               one_twenty_deg = new_edge_time - previous_edge_time;
               //thirty_deg=one_twenty_deg/4;
               //period_measurement=one_twenty_deg*3;
               //period6ZC = one_twenty_deg*3;
               actualSpeed = SPEED_CALC_NUMERATOR / (one_twenty_deg * 3);

               if (control_flags.DIR == FORWARDS)
               {
                   control_flags.WINDMILLING = TRUE;
                   //control_flags.ROTATION_CHECK=FALSE;
                   control_flags.DIR = BACKWARDS;
                   control_flags.INIT_ACQUIRE = FALSE;
                   if (actualSpeed > CHECK_MIN_SPEED)
                       BrakeLoopDuration = 2000;
                   else
                       BrakeLoopDuration = 1000;
                   AppTranToBrake();
                   return;
               }

               if (actualSpeed < (CHECK_MIN_SPEED * 30)) // If OK to run sensorless
               {
                   NextCmtPeriod = one_twenty_deg / 2;
                   duty_cycle = 0; ///duty = 10%;
                   //AppFreewheelToRun();
               }
               else
               {
                   control_flags.INIT_ACQUIRE = TRUE;
                   control_flags.ROTATION_CHECK = TRUE;
                   //CURRENT_LIMIT_LED = 1;
               }
               return;
           }
           previous_edge_time = new_edge_time;
           control_flags.ACQUIRE_BLUE = TRUE;
       }
   }
   /********************** END OF BLUE PHASE CODE *********************************/

   // Save current VPH samples for use next call of routine
   // Note that code above only returns before this point if an action is being taken
   // on a rising edge detect.

   previous_vph_red = vph_red;
   previous_vph_yellow = vph_yellow;
   previous_vph_blue = vph_blue;

   return;
}

/*****************************************************************************
*
* Function: void AppTranToBrake(void)
*
* Description: Stop function, ready to Brake
*
*****************************************************************************/
void AppTranToBrake(void)
{
   control_flags.DIR = FORWARDS;
   // Turn on Actuator output on (PWM,GDU)
   EnableOutput();

   drvFOC.uDQReq.f16Arg1 = drvFOC.alignVoltage;
   drvFOC.uDQReq.f16Arg2 = FRAC16(0);

   drvFOC.thTransform.f16Arg1 = GFLIB_Sin(0);
   drvFOC.thTransform.f16Arg2 = GFLIB_Cos(0);

   GMCLIB_ParkInv(&(drvFOC.uAlBeReq), &(drvFOC.thTransform), &(drvFOC.uDQReq));
   drvFOC.svmSector = GMCLIB_SvmStd(&(drvFOC.pwm16), &(drvFOC.uAlBeReq));
   SetDutycycle(&drvFOC.pwm16, drvFOC.svmSector);

   cntrState.state = brake;
   cntrState.event = e_brake;
}

void AppBrakeToAlignment(void)
{
   drvFOC.iDQReq.f16Arg1 = FRAC16(0.0);
   drvFOC.iDQReq.f16Arg2 = FRAC16(0.0);

   drvFOC.uDQReq.f16Arg1 = 0;
   drvFOC.uDQReq.f16Arg2 = 0;

   drvFOC.dAxisPI.f16InErrK1 = 0;
   drvFOC.dAxisPI.f32Acc = 0;

   drvFOC.qAxisPI.f16InErrK1 = 0;
   drvFOC.qAxisPI.f32Acc = 0;

   drvFOC.pwm16.f16Arg1 = FRAC16(0.5);
   drvFOC.pwm16.f16Arg2 = FRAC16(0.5);
   drvFOC.pwm16.f16Arg3 = FRAC16(0.5);

   drvFOC.svmSector = 2;

   cntrState.state = align;
   cntrState.event = e_align;
}

void AppCalibToCheckMotor(void)
{
   // Turn off actuator output
   DisableOutput();

   RunningChk_counter = 0;
   actualSpeed = 0;
   control_flags.INIT_ACQUIRE = TRUE;
   control_flags.RETRY_FLAG = FALSE;
   control_flags.DIR = FORWARDS;

   vph_red = 0;
   vph_yellow = 0;
   vph_blue = 0;

   NextCmtSector = 0;
   ADC_channel = 3;
   GDUPHMUX_GPHMX = ADC_channel; // will be applied at the next PMF Reload
   PTUC_PTULDOK = 1;

   cntrState.state = checkM;
   cntrState.event = e_check;
}

void AppFreewheelToRun(void)
{
   //drvFOC.svmSector = NextCmtSector;

   drvFOC.pospeOpenLoop.wRotEl = MLIB_DivSat_F16(actualSpeed, N_MAX); //FRAC16((float)actualSpeed/N_MAX);
   drvFOC.pospeOpenLoop.thRotEl = 0;
   drvFOC.pospeSensorless.wRotEl = 0;
   drvFOC.pospeSensorless.thRotEl = 0;
   drvFOC.speedPI.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
   drvFOC.speedPI.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedPI.f16UpperLimit);

   AMCLIB_BemfObsrvDQInit_F16(&drvFOC.pospeSensorless.bEMFObs);

   drvFOC.pospeSensorless.TrackObsrv.pParamPI.f32Acc = ((tFrac32)drvFOC.pospeOpenLoop.wRotEl << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift));
   drvFOC.pospeSensorless.filterMA.f32Acc = ((tFrac32)drvFOC.pospeOpenLoop.wRotEl << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift));
   drvFOC.pospeSensorless.TrackObsrv.pParamInteg.f32State = ((tFrac32)(drvFOC.pospeOpenLoop.thRotEl) << (16 + drvFOC.pospeSensorless.TrackObsrv.pParamInteg.u16NShift));

   // Turn on Actuator output on (PWM,GDU)
   EnableOutput();

   LinkupDuration = 500;
   pos_mode = linkup;
   cntrState.state = run;
   cntrState.event = e_run;
}
